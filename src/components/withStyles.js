/**
 * https://github.com/kriasoft/react-starter-kit/pull/1132
 */
import React, { Component } from 'react';
import PropTypes from 'prop-types';
import hoistStatics from 'hoist-non-react-statics';

/**
 * Insert StyleSheet object generated by `inline-css-loader` into DOM
 */
let cache;

function insertCss(props, update) {
  const { id, cssText } = props;

  if (!cache) {
    cache = {};

    // Grab the style elements from the DOM
    [...document.head.getElementsByTagName('style')].forEach(elem => {
      const dataId = elem.getAttribute('data-id');
      if (dataId) {
        cache[dataId] = { diff: 0, elem, cssText: elem.textContent };
      }
    });
  }

  let inserted = cache[id];
  let isDifferent = false;

  // If the object doesn't exist in the cache,
  //  add it there, so we can reuse it below.
  if (!inserted) {
    inserted = { diff: 0, elem: null, cssText };
    cache[id] = inserted;
  }

  // If the CSS is different from what's been loaded from the DOM
  //  make sure to replace the styles on the DOM.
  if (inserted.cssText !== cssText) {
    isDifferent = true;
    inserted.cssText = cssText;
    inserted.elem.textContent = cssText;
  }

  // If the styles are fresh and new, and not on the page yet,
  //  put them there, and make sure we can get to them if they
  //  change - because, HMR!
  if (!inserted.elem) {
    const elem = document.createElement('style');
    inserted.elem = elem;
    elem.setAttribute('data-id', id);
    elem.textContent = cssText;
    document.head.appendChild(elem);
  }

  if (!update && isDifferent) {
    inserted.count += 1;
  }

  // Prevent flash of unstyled content (FOUC)
  return () =>
    setTimeout(() => {
      inserted.count -= 1;
      if (inserted.count <= 0 && inserted.elem) {
        inserted.elem.parentNode.removeChild(inserted.elem);
        inserted.elem = null;
      }
    }, 0);
}

function withStyles(...styles) {
  return function wrapWithStyles(ComposedComponent) {
    class WithStyles extends Component {
      componentWillMount() {
        // Server side
        if (this.context.insertCss) {
          this.inserted = [];
          styles.forEach(s => this.context.insertCss(s));

          // Client side
        } else {
          this.inserted = styles.map(s => insertCss(s.getCss()));
        }
      }

      componentWillUnmount() {
        this.inserted.forEach(remove => remove());
      }

      render() {
        return <ComposedComponent {...this.props} />;
      }
    }

    // Enable Hot Module Replacement (HMR)
    if (module.hot) {
      WithStyles.prototype.componentWillReceiveProps = function componentWillReceiveProps() {
        this.inserted = styles.map(s => insertCss(s.getCss(), true));
      };
    }

    const displayName =
      ComposedComponent.displayName || ComposedComponent.name || 'Component';

    WithStyles.displayName = `WithStyles(${displayName})`;
    WithStyles.contextTypes = { insertCss: PropTypes.func };
    WithStyles.ComposedComponent = ComposedComponent;

    return hoistStatics(WithStyles, ComposedComponent);
  };
}

export default withStyles;
